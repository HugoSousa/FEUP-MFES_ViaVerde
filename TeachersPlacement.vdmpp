class TeachersPlacement

  types
    public Vaga = token;
    public Professor = token;
    public Colocacao =  inmap Professor to Vaga;

  operations
		-- Função que calcula a colocação de professores.
		-- Argumentos:
    --  vagas: conjunto de vagas a concurso (inclui posições ocupadas inicialmente por professores que querem mudar).
    --  professores: conjunto de professores, ordenado por ranking (sequência)        
    --  preferencias: indica para cada professor uma lista ordenada de vagas pretendidas por ordem decrescente
    --  colocacaoInicial: indica os professores que tinham colocação inicial e qual a sua colocação inicial
    -- Resultados:
    --  colocacaoFinal : colocação final dos professores
    -- Algoritmo: algoritmo dos casamentos estáveis de Gale-Shapley.
    public static colocaProfessores(vagas: set of Vaga, professores: seq of Professor, 
    	preferencias: map Professor to seq of Vaga, colocacaoInicial: Colocacao) colocacaoFinal: Colocacao ==
    (
			dcl colocacaoProvisoria: Colocacao := {|->};
			dcl prefsRestantes: map Professor to seq of Vaga := preferencias;
			dcl profsColocaveis: seq of Professor := professores; 
			
			while profsColocaveis <> [] do
			(
  			-- escolhe um professor colocável (p) e a vaga (v) à cabeça da sua lista de preferências
  			-- (esolhe o 1º professor por ordem de ranking, mas não era obrigatório)
  			dcl p : Professor := hd profsColocaveis;
  			dcl v : Vaga := hd prefsRestantes(p);
     		
				-- coloca o professor escolhido na vaga preferida, tirando quem aí estava eventualmente
     		colocacaoProvisoria := (colocacaoProvisoria :-> {v}) munion {p |-> v}; 

     		-- tira esta vaga das listas de preferências de todos os professores candidatos a esta
     		-- vaga, mas com menor prioridade que o professor seleccionado
     		for all p2 in set dom prefsRestantes do
        	if v in set elems prefsRestantes(p2) then
           	if temPrecedencia(p, p2, v, professores, colocacaoInicial) then
             	prefsRestantes(p2) := remove[Vaga](v, prefsRestantes(p2));

     		-- recalcula os professores colocáveis (por colocar, c/lista de preferências não vazia)
     		profsColocaveis := [professores(i) | i in set inds professores &
          		professores(i) not in set dom colocacaoProvisoria
							and prefsRestantes(professores(i)) <> [] ] 
			);
			
			return colocacaoProvisoria
		)
    pre 
      true -- so para compilar
      -- P1: a sequência de professores não tem repetições                  

      -- P2: todos os professores indicam preferências
          
      -- P3: as vagas referidas nas preferências estão no conjunto das vagas
          
      -- P4: a lista de preferências de um professor não tem repetições 
          
      -- P5: os professores com colocação inicial estão no conjunto dos professores 
          
      -- P6: as vagas referidas na colocação inicial estão no conjunto das vagas 
      -- (implicado por P3 e P7) 
          
      -- P7: no caso de professores que tinham colocação inicial, a sua colocação inicial 
      -- deve estar no fim da lista de preferências
          

    post 
      true -- so' para compilar
      -- Q1: os professores referidos na colocação final têm de estar no conjunto de professores 
        
      -- Q2: as vagas referidas na colocação final têm de estar no conjunto de vagas 
         
      -- Q3: um professor só pode ser colocado numa vaga que está na sua lista de preferências 
        
      -- Q4: os professores que estavam inicialmente colocados têm de continuar colocados no fim 
        
      -- Q5: todas as vagas pretendidas por um professor, com maior preferência em relação à posição 
      -- em que ficou, têm de estar ocupadas por alguém com precedência em termos de ranking ou por 
      -- quem aí estava colocado inicialmente
        
    ;


functions
    private temPrecedencia(p1: Professor, p2: Professor, v: Vaga, 
    	professores: seq of Vaga, colocacaoInicial: Colocacao) res: bool ==
    (
      if p1 in set dom colocacaoInicial and colocacaoInicial(p1) = v then true
      else if p2 in set dom colocacaoInicial and colocacaoInicial(p2) = v then false
      else index[Professor](p1, professores) < index[Professor](p2, professores)
    );

    -- Checks if a sequence of elements of type @T has no duplicates
    public hasRepetitions[@T](s: seq of @T) res: bool ==
      exists i, j in set inds s & i <> j and s(i) = s(j);
    
    -- Removes an element from a sequence  of elements of type @T
    public remove[@T](e: @T, s: seq of @T) res: seq of @T ==
    	[s(i) | i in set inds s & s(i) <> e];
    
    -- Obtains the index of an element in a sequence of distinct elements of type @T
    public index[@T](e: @T, s: seq1 of @T) res: nat1 ==
      iota i in set inds s & s(i) = e
    pre (e in set elems s) and not hasRepetitions[@T](s);
    
end TeachersPlacement
