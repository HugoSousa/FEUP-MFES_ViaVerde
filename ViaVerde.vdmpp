class ViaVerde

  types
  	public Nome = seq1 of char;
  	public OriginDestiny :: origin: HighwayNode
  													destination: HighwayNode
  													classe: Client`class_v;
  values
	--    
	instance variables
		--tabela de preços tem de estar no sistema, pois é possivel intercalar em auto-estradas de diferentes concessionárias
		public highway_prices : map OriginDestiny to real := { |-> };
	
	  public clients : set of Client := {};
	  private service_providers : set of ServiceProvider := {};
	  private records : map Client to seq of Record := { |-> };
	  
  	--inv not exists node in set getAllNodes() & card node > 1;
  
  --operations
  operations
   
  --adiciona um cliente
  public addClient(client: Client) ==
  (
    clients := clients union {client};
    records := records munion {client |-> []};
    IO`println(clients);
  )
    post 
     	clients <> {};
  
  --remove um cliente   	
  public removeClient(client: Client) == 
  ( 	
  	--IO`println(cliente.name);
  	--clientes := clientes \ {cliente};
  	--percorrer o set e comparar o nome
		clients := clients \ {client};
		
		-- IO`println(clients);
  );
	
	--adiciona uma parceria com um fornecedor de servicos (parque estacionamento, auto-estradas, etc.)
	public addServiceProvider(provider: ServiceProvider) == (
		service_providers := service_providers union {provider};
    IO`println(service_providers);
	);
		
	--TODO o cliente tem de estar adicionado no sistema
	public passa(client: Client, node : Node, time: Time) == (
	  dcl estab : [ServiceProvider] := nil;
	  dcl cost : real;
	  dcl new_record : Record;
	  dcl last_record : [Record];
	  dcl client_records : seq of Record;
	  
	  
	  --verifica se entrou antes numa AE
	  --se nao entrou, entao assumir que esta a entrar na AE
  	--senao retorna preco, indo buscar ao map
	  if (isofclass(HighwayNode, node)) then
		(
			last_record := getLastHighwayRecord(client);
			if(last_record = nil) then
		 	(
			 cost:= 0.0;
		 	)
			elseif (isofclass(HighwayNode, last_record.node)) then
			(
				cost := highway_prices(mk_OriginDestiny(last_record.node, node, client.class_vehicle));
			)
			else
			(cost := 0.0);
		)
  	else
	 	(
	 		estab := getServiceProviderByNode(node);
		  	
		   
		  last_record := getLastRecord(client, estab);
	 	
	 		cost := estab.passa(client, node, time, last_record)
	 	);
  	
	  
		
		client_records := records(client);
		new_record := new Record(client, node, time, estab, cost);
		client_records := client_records ^ [new_record];
		records := records ++ { client |-> client_records };
		IO`println("AFTER RECORDS: " ^ records(client));
		
	);

	--remove uma parceria com um fornecedor de servicos
	public removeServiceProvider(provider: ServiceProvider) == 
  ( 	
  	dcl sp1 : ServiceProvider;
  	sp1 := iota sp in set service_providers & sp.id = provider.id;
  	
		service_providers := service_providers \ {sp1};
		
		-- IO`println(clients);
  );
  
  
  public getAllNodes : () ==> set of Node
	 getAllNodes() == (
	 	dcl all_nodes: set of Node := {};
	 	
	 	for all service_provider in set service_providers do
    	all_nodes := all_nodes union service_provider.getAllNodes();
    	
  	return all_nodes;
	 );
		 
	
	 public getServiceProviderByNode : Node ==> ServiceProvider
	 getServiceProviderByNode(node) == (
		
		dcl all_nodes : set of Node := {};
		dcl service_provider: ServiceProvider;
		
		for all sp in set service_providers do(
			all_nodes := sp.getAllNodes();
			if(node in set all_nodes) then 
				service_provider:= sp;
		);

  	return service_provider;
	 );
	 
	public getLastRecord : Client * ServiceProvider ==> [Record]
	getLastRecord(client, serviceProvider) == (
		dcl client_records : seq of Record;
		dcl last_record: [Record] := nil;
	  
	  client_records := records(client);
	  
	  for all c in set elems client_records do
  		if (serviceProvider = c.provider) then
  			last_record := c;
  			
  	return last_record;
	);
	
	public getLastHighwayRecord : Client ==> [Record]
	getLastHighwayRecord(client) == (
		dcl client_records : seq of Record;
		dcl last_highway_record : [Record] := nil;
		
		client_records := records(client);
	  client_records := reverse client_records;
	  
	  for r in client_records do
	  if (isofclass(HighwayNode, r.node)) then
	  	last_highway_record := r;
	  	
	  return last_highway_record;
	);
	
functions
   
end ViaVerde
